#ifndef RASGUEADB_GLOBAL_UTILS
#define RASGUEADB_GLOBAL_UTILS

static inline std::string_view sv(const flatbuffers::Vector<unsigned char> *p) {
    return p ? std::string_view(reinterpret_cast<const char*>(p->data()), p->size()) : "";
}

static inline std::string_view sv(const flatbuffers::String *p) {
    return p ? std::string_view(reinterpret_cast<const char*>(p->data()), p->size()) : "";
}

/** From LMDB: Compare two items lexically */
static int mdb_cmp_memn(const MDB_val *a, const MDB_val *b) {
    int diff;
    ssize_t len_diff;
    unsigned int len;

    len = a->mv_size;
    len_diff = (ssize_t) a->mv_size - (ssize_t) b->mv_size;
    if (len_diff > 0) {
        len = b->mv_size;
        len_diff = 1;
    }

    diff = memcmp(a->mv_data, b->mv_data, len);
    return diff ? diff : len_diff<0 ? -1 : len_diff;
}

static int lmdb_comparator__StringUint64(const MDB_val *a, const MDB_val *b) {
    if (a->mv_size < 8 || b->mv_size < 8) throw hoytech::error("StringUint64 key too short to compare");

    MDB_val a2 = *a, b2 = *b;
    a2.mv_size -= 8;
    b2.mv_size -= 8;

    auto stringCompare = mdb_cmp_memn(&a2, &b2);
    if (stringCompare) return stringCompare;

    uint64_t ai, bi;
    memcpy(&ai, (char*)a->mv_data + a->mv_size - 8, 8);
    memcpy(&bi, (char*)b->mv_data + b->mv_size - 8, 8);

    return ai - bi;
}

static inline std::string makeKey_StringUint64(std::string_view s, uint64_t n) {
    return std::string(s) + std::string(lmdb::to_sv<uint64_t>(n));
}

struct ParsedKey_StringUint64 {
    std::string_view s;
    uint64_t n;

    ParsedKey_StringUint64(std::string_view k) {
        if (k.size() < 8) throw hoytech::error("StringUint64 key too short to parse");
        s = k.substr(0, k.size() - 8);
        n = lmdb::from_sv<uint64_t>(k.substr(k.size() - 8, 8));
    }
};

#endif
