# RasgueaDB

Indexing and querying layer for [LMDB](https://github.com/hoytech/lmdbxx) and [flatbuffers](https://google.github.io/flatbuffers/). Compiles a YAML schema to a C++ header file.


## Synopsis

Here is an example schema:

    db: example

    tables:
      User:
        tableId: 1

        fields:
          - name: userName
            type: string
            unique: true
          - name: passwordHash
            type: ubytes
          - name: created
            index: true
            ## default type is uint64

After compiling the schema, here is an example program that shows how to use the generated header:

    #include <iostream>
    #include "build/example.h"

    int main() {
        example::environment env;

        env.open("/path/to/db/");

        // Populate a record

        {
            auto txn = env.txn_rw();
            env.insert_User(txn, "john", "\x01\x02\x03", 1000);
            txn.commit();
        }

        // Query a record by userName

        {
            auto txn = env.txn_ro();
            auto view = env.lookup_User__userName(txn, "john");
            if (!view) return -1; // not found
            std::cout << view->userName() << std::endl;
        }

        // Loop over all records

        {
            auto txn = env.txn_ro();
            env.foreach_User(txn, [&](auto &view){
                std::cout << view.userName() << std::endl;
                return true; // keep looping
            });
        }

        return 0;
    }

## Insertion

Insert a new record:

    env.insert_User(txn, "john", "\x01\x02\x03", 1000);

All fields are `std::string_view`s, except for integer fields which accept C++ integers. There is no difference between `string` and `ubytes` schema types, except for how they are displayed in debugging.

This must be done inside a read-write transaction (this also holds for updates and deletions).

## Lookup by primary key

Every record that is insered has a primary key. By default this is a special integer field that is autogenerated, although this can be overridden with the `primaryKey` schema specifier (which must be of type `uint64`).

For example, here is how you can lookup the record with the primary key of `2`:

    auto view = env.lookup_User(txn, 2);

`view` is of type `std::optional<View_User>`. If the record was not found, then this will be `std::nullopt`. Otherwise, it is a "pointer" to a `View_User` object which provides accessors for each field, and the primary key for the record:

    std::string_view userName = view->userName();
    uint64_t primaryKey = view->primaryKey;

## Update

To Update a record (C++20):

    env.update_User(txn, view, { .userName = "new username", });

When you update, all the indices will be updated as well. Like inserts, updates can fail if a unique constraint is violated.

If you use the C++20 way with [designated initialisers](https://en.cppreference.com/w/cpp/language/aggregate_initialization) then the fields must be in the same order as they are defined in the schema otherwise you will get a compile-time error. If you don't want to use designated initialisers, you can do it like this:

    example::environment::Updates_User upd;
    upd.username = "new username";
    env.update_User(txn, view, upd);

## Delete

To delete a record, you need its primary key, which you can retrieve from a view:

    env.delete_User(txn, view.primaryKeyId);

## Lookup by index

If a field is indexed, then you can lookup a record like this:

    auto view = env.lookup_User__userName(txn, "alice");

If there are multiple matching records, then it returns the first one it finds.

For an integer index, you have to convert the value to a `string_view`:

    auto view = env.lookup_User__created(txn, lmdb::to_sv<uint64_t>(1001));

## Iteration over table

To iterate over a whole table:

    env.foreach_User(txn, [&](auto &view){
        // ...
        return true;
    });

Your callback must return a `bool` which indicates whether the looping should continue. You can use this to implement `LIMIT`-like functionality. Note: If you forget the `return true` you'll get a really inscrutable compile-time error.

## Iteration over index

This iterates over all the entries in an index. In this case, it will be the same as the previous example, except the records will be sorted by `userName`:

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    });

If you wanted to start at a particular record, you can pass this in as the next parameter:

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    }, "bob");

This will start the iteration at `bob` (skipping over all records with `userName` lexically preceeding). By combining this from the boolean returned from your callback, you can perform range-queries.

The next optional argument is a boolean that signifies the index should be iterated over in reverse (`std::nullopt` just says to start at the end):

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    }, std::nullopt, true);

## Unique

If you specify `unique` in your schema (see the `userName` field in the synopsis) then when you insert a record it will make sure no other records have the same value for this index. If there are, then it will throw an exception.

However, by default duplicates are allowed, and in the index these duplicates will be sorted by primary key.

## Iteration of dup records

Loop over all records with a particular value for an indexed field:

    env.foreachDup_User__created(txn, lmdb::to_sv<uint64_t>(1001), [&](auto &view){
        // ...
        return true;
    });

## Multi-indices
