# RasgueaDB

Indexing and querying layer for [LMDB](https://github.com/hoytech/lmdbxx) and [flatbuffers](https://google.github.io/flatbuffers/). Compiles a YAML schema to a C++ header file.

These wrapper templates let you maintain multiple indices for your records, and maintain those indices on updates and deletions.

Accessing fields results in `std::string_view`s that point into the LMDB memory map, for zero-copy access.

The iteration and querying functionality is flexible, and is all done within the same compilation unit as database access so there is very minimal overhead over using LMDB directly.


## Synopsis

Here is an example schema:

    db: example

    tables:
      User:
        tableId: 1

        fields:
          - name: userName
            type: string
            unique: true
          - name: passwordHash
            type: ubytes
          - name: created
            index: true
            ## default type is uint64

After compiling the schema, here is an example program that shows how to use the generated header:

    #include <iostream>
    #include "build/example.h"

    int main() {
        example::environment env;

        env.open("/path/to/db/");

        // Populate a record

        {
            auto txn = env.txn_rw();
            env.insert_User(txn, "john", "\x01\x02\x03", 1000);
            txn.commit();
        }

        // Query a record by userName

        {
            auto txn = env.txn_ro();
            auto view = env.lookup_User__userName(txn, "john");
            if (!view) return -1; // not found
            std::cout << view->userName() << std::endl;
        }

        // Loop over all records

        {
            auto txn = env.txn_ro();
            env.foreach_User(txn, [&](auto &view){
                std::cout << view.userName() << std::endl;
                return true; // keep looping
            });
        }

        return 0;
    }

## Insert

Insert a new record:

    env.insert_User(txn, "john", "\x01\x02\x03", 1000);

All fields are `std::string_view`s, except for integer fields which accept C++ integers. There is no difference between `string` and `ubytes` schema types, except for how they are displayed in debugging.

This must be done inside a read-write transaction (this also holds for updates and deletions).

## Lookup by primary key

Every record that is insered has a primary key. By default this is a special integer field that is autogenerated, although this can be overridden with the `primaryKey` schema specifier (which must be of type `uint64`).

For example, here is how you can lookup the record with the primary key of `2`:

    auto view = env.lookup_User(txn, 2);

`view` is of type `std::optional<View_User>`. If the record was not found, then this will be `std::nullopt`. Otherwise, it is a "pointer" to a `View_User` object which provides accessors for each field, and the primary key for the record:

    std::string_view userName = view->userName();
    uint64_t primaryKey = view->primaryKey;

## Update

To Update a record (C++20):

    env.update_User(txn, view, { .userName = "new username", });

When you update, all the indices will be updated as well. Like inserts, updates can fail if a unique constraint is violated.

If you use the C++20 way with [designated initialisers](https://en.cppreference.com/w/cpp/language/aggregate_initialization) then the fields must be in the same order as they are defined in the schema otherwise you will get a compile-time error. If you don't want to use designated initialisers, you can do it like this:

    example::environment::Updates_User upd;
    upd.username = "new username";
    env.update_User(txn, view, upd);

## Delete

To delete a record, you need its primary key, which you can retrieve from a view:

    env.delete_User(txn, view.primaryKeyId);


## Unique

A `unique` modifier can be specified on an index:

        fields:
          - name: userName
            type: string
            index:
              unique: true

When you insert a record it will check that no other records have the same value for this index. If there are, then it will throw an exception.

By default duplicates *are* allowed, and in the index these duplicates are sorted by primary key.


## Lookup by index

If a field is indexed, then you can lookup a record like this:

    auto view = env.lookup_User__userName(txn, "alice");

If there are multiple matching records, then it returns the first one it finds.

For an integer index, you have to convert the value to a `string_view`:

    auto view = env.lookup_User__created(txn, lmdb::to_sv<uint64_t>(1001));

## Iteration over table

To iterate over a whole table:

    env.foreach_User(txn, [&](auto &view){
        // ...
        return true;
    });

Your callback must return a `bool` which indicates whether the looping should continue. You can use this to implement `LIMIT`-like functionality. Note: If you forget the `return true` you'll get a really inscrutable compile-time error.

The records will be iterated over in order of their primary keys.

## Iteration over index

This iterates over all the entries in an index. In this case, it will be the same as the previous example, except the records will be sorted by `userName`:

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    });

If you wanted to start at a particular record, you can pass this in as the next parameter:

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    }, "bob");

This will start the iteration at `bob` (skipping over all records with `userName` lexically preceeding). By combining this from the boolean returned from your callback, you can perform range-queries.

The next optional argument is a boolean that signifies the index should be iterated over in reverse (`std::nullopt` just says to start at the end):

    env.foreach_User__userName(txn, [&](auto &view){
        // ...
        return true;
    }, std::nullopt, true);

## Iteration over dup records

Unless an index is marked `unique`, there can be multiple records with the same value. Here is how to loop over all records that have a particular indexed value:

    env.foreachDup_User__created(txn, lmdb::to_sv<uint64_t>(1001), [&](auto &view){
        // ...
        return true;
    });

## Derived indices

Although you can say that a particular field is indexed by adding an `index` key to the field, you can also have indices that don't directly correspond to fields. You can construct their values with arbitrary C++ code by including an `indexPrelude` and then a set of `indices` to add:

As an example, here is definition of a table that maintains indices of its two fields in lower-case:

      Person:
        tableId: 2

        fields:
          - name: fullName
            type: string
          - name: email
            type: string

        indexPrelude: |
          std::string fullNameLC = std::string(v.fullName());
          std::string emailLC = std::string(v.email());
          std::transform(fullNameLC.begin(), fullNameLC.end(), fullNameLC.begin(), ::tolower);
          std::transform(emailLC.begin(), emailLC.end(), emailLC.begin(), ::tolower);

        indices:
          fullNameLC:
            accessor: 'fullNameLC'
          emailLC:
            accessor: 'emailLC'
            unique: true

Now records can be queried using the index without worrying about casing, but the original user's chosen casing is preserved.

Note that the `emailLC` index is also `unique`. This will prevent duplicated records from being inserted, even if the casing is different.

IMPORTANT: When deriving index values, given the same view (accessible as `v`) you must always compute the exact same index values, otherwise your database will become corrupted. It is recommended to only use data from `v` to compute the values (and nothing else).

## Multi-indices

A `multi` modifier can also be added to an index definition. This is for when a record should get multiple entries in the same index.

The test-suite has an example where a `words` field is split up into individual words and each is added to a multi-index. This way you can query for all records that contain a particular word somewhere in their `words` field.

## Author and Copyright

RasgueaDB Â© 2021 Doug Hoyte.

2-clause BSD license. See the LICENSE file.

Does this stuff interest you? Subscribe for news on my upcoming book: [Zero Copy](https://leanpub.com/zerocopy)!
